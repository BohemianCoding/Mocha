{"name":"Mocha","tagline":"Objective-C / JavaScript Bridge and Scripting Environment","body":"# Mocha\r\n### Objective-C / JavaScript Bridge and Scripting Environment\r\n\r\n\r\nMocha is a runtime that bridges JavaScript to Objective-C. It is built on top of JavaScriptCore, the component of WebKit responsible for parsing and evaluating JavaScript code, and BridgeSupport, which enables libraries to expose the definition of their C structures and functions for use at run-time (as opposed to compile-time).\r\n\r\n\r\n## Usage\r\n\r\nInstances of the `Mocha` class are representations of a runtime. A runtime can be used either through shared instance (returned from `+sharedRuntime`) or by creating an instance by calling `-init`.\r\n\r\n\r\n## Values and Boxed Objects\r\n\r\nWhen arguments are passed between the Objective-C and JavaScript sides of the bridge they may be implicitly converted to an appropriate type counterpart or boxed within an opaque proxy object. The following type conventions are in effect when moving between each side of the bridge:\r\n\r\n### Objective-C to JavaScript\r\n- `nil` is converted to `null`\r\n- `MOUndefined` is converted to `undefined`\r\n- `char*` is converted to `String`\r\n- **Objective-C methods** are converted to `MOMethod`, and are callable\r\n- **Blocks** are boxed within an opaque `Object` type, and are callable\r\n- **C functions** are boxed within an opaque `Object` type, and are callable\r\n- **C structs** are boxed within an opaque `Object` type, allowing direct access to members in a dictionary-like manner.\r\n- **C numeric primitives** (`int`, `long`, `short`, `char`, `float`, `double`, etc.) are converted to `Number`\r\n- `bool` and `_Bool` are converted to `Boolean`\r\n- **Pointers** are boxed within an opaque `Object` type\r\n- **All other Objective-C objects** are boxed within an opaque `Object` type. This type can be converted to `String` or `Number` from within JavaScript. `NSString` instances will convert to `String` appropriately. `NSNumber` instances will convert to `Number` appropriately. All other conversions will use the `-description` method of the `NSObject` subclass.\r\n\r\nNote: `BOOL`, unlike `bool`, is converted to `Number`, as `BOOL` is typedef'd as an `unsigned char` in Objective-C.\r\n\r\n### JavaScript to Objective-C\r\n- `null` is converted to `nil` (when bare) or `NSNull` (when placed in a container)\r\n- `undefined` is converted to `MOUndefined`\r\n- `String` is converted to `NSString` or `char*`, depending on context\r\n- `Number` is converted to `NSNumber` or a **C numeric primitive**, depending on context\r\n- `Boolean` is converted to `NSNumber`, `bool`, or `_Bool`, depending on context\r\n- `Array` is converted to `NSArray`\r\n- **JavaScript functions** are boxed within an opaque class\r\n- **All boxed types** are unboxed\r\n- All other pure `Object` types are converted to `NSDictionary`\r\n\r\n\r\n## Callables\r\n\r\n### Functions, Methods, and Blocks… Oh My!\r\n\r\nAll three of these constructs are automatically converted across the bridge. The specifics of how each of them are boxed is different, but the end result is the same: All three are available to be called from within the runtime as if they were a normal JavaScript function.\r\n\r\n\r\n#### Example:\r\n<pre>\r\n// ObjC\r\ntypedef NSString * (^UppercaseBlock)(NSString *);\r\nUppercaseBlock toUppercaseBlock = [myObject toUppercaseBlock];\r\ntoUppercaseBlock(@\"Hello, World!\");\r\n>>> \"HELLO, WORLD!\"\r\n\r\n// JavaScript\r\nvar toUppercaseBlock = myObject.toUppercaseBlock();\r\ntoUppercaseBlock(\"Hello, World!\");\r\n>>> \"HELLO, WORLD!\"\r\n</pre>\r\n\r\n\r\n### Arguments\r\n\r\nArguments to boxed callables are automatically converted when crossing the bridge. Care is taken to automatically allocate storage space for return values and maintain type consistency between the C, Objective-C, and JavaScript layers.\r\n\r\nCallables that return other callables (e.g. a block that returns another block) or take callables as arguments also work as expected.\r\n\r\nVariable-argument functions work as expected. Objective-C methods that require a terminating sentinel (through the `NS_REQUIRES_NIL_TERMINATION` compiler attribute) **do not** require a trailing `null`.\r\n\r\n#### Example:\r\n<pre>\r\n// ObjC\r\nNSArray *array = [NSArray arrayWithObjects:first, second, third, nil];\r\n\r\n// JavaScript\r\nvar array = NSArray.arrayWithObjects_(first, second, third);\r\n</pre>\r\n\r\nSince JavaScript is a dynamic, weak, duck typed language, type safety is key. Mocha will throw an exception if a callable receives more or fewer arguments than is expected, but the actual type of those arguments is mostly left up to the user. The runtime will attempt to convert the JavaScript arguments to the appropriate type as best it can.\r\n\r\n**This is an important note:** While normal JavaScript functions can have optional arguments, callables provided from the bridge must receive the exact number of arguments that are expected. (Except in the case of variadic functions, in which case the *minimum* number of arguments needed for calling are required.)\r\n\r\n\r\n### Objective-C Selectors\r\n\r\nObjective-C methods are exposed as properties of the object's opaque JavaScript proxy. When a method is invoked, it is automatically converted to the appropriate selector on the Objective-C side of the bridge, and all arguments are converted to the appropriate types.\r\n\r\nMethod name conversion follow a similar pattern to PyObjC. The following steps are taken when converting a selector name to the JavaScript property name:\r\n- All colons are converted to underscores.\r\n- Each component of the selector is concatenated into a single string with no separation.\r\n\r\nAs such, a selector such as `executeOperation:withObject:error:` is converted to the function name `executeOperation_withObject_error_()`. The reverse is done to convert the property name back into an Objective-C selector.\r\n\r\nIf you wish to change this behavior (for example, to shorten an Objective-C method name for ease of use), you can. Use the `+selectorForMochaPropertyName:` method, defined within a category on NSObject. Objects implementing this method can return the selector for a give JavaScript property name, which will cause the runtime to forward invocations of that property to the appropriate method selector.\r\n\r\n#### Example:\r\n<pre>\r\n// ObjC\r\n@implementation MyClass\r\n…\r\n\r\n+ (SEL)selectorForMochaPropertyName:(NSString *)propertyName; {\r\n    if ([propertyName isEqualToString:@\"someMethod\") {\r\n        return @selector(someMethodTakingArgument:otherArgument:)\r\n    }\r\n    return [super selectorForMochaPropertyName:propertyName];\r\n}\r\n\r\n@end\r\n\r\n// JavaScript\r\nmyObject.someMethod(argument, otherArgument);\r\n</pre>\r\n\r\n\r\n### Objective-C Properties\r\n\r\nObjective-C properties behave as they should on the JavaScript side of the bridge. Invoking a property will immediately return its value (as opposed to methods, which return a callable object). A property can also be set using the normal setter syntax. For this to work, the property must be declared using the Objective-C @property syntax.\r\n\r\n#### Example:\r\n<pre>\r\n// JavaScript\r\nmyObject.name;\r\n>>> \"Foobar\"\r\n\r\nmyObject.name = \"Baz\";\r\n\r\nmyObject.name;\r\n>>> \"Baz\";\r\n</pre>\r\n\r\n\r\n### Exposing Objective-C methods\r\n\r\nBy default, all methods and properties of an Objective-C object crossing the bridge are available to be invoked. If you wish to specifically exclude methods from invocation on the JavaScript side of the bridge, use the `+isSelectorExcludedFromMochaScript:` method. Objects implementing this method can return `YES` for any selector that should not be invoked from the bridge.\r\n\r\n#### Example:\r\n<pre>\r\n// ObjC\r\n@implementation MyClass\r\n…\r\n\r\n+ (BOOL)isSelectorExcludedFromMochaScript:(SEL)selector {\r\n    if (selector == @selector(someMethod)) {\r\n        return YES;\r\n    }\r\n    return [super isSelectorExcludedFromMochaScript:selector];\r\n}\r\n\r\n@end\r\n\r\n// JavaScript\r\nvar result = myObject.someMethod();\r\n>>> \"MOJavaScriptException: ReferenceError: Can't find variable: someMethod\"\r\n</pre>\r\n\r\n\r\n## Frameworks\r\n\r\nFrameworks that expose BridgeSupport information (as all public OS X frameworks do) can be imported through the use of the `framework` built-in function.\r\n\r\n#### Example:\r\n<pre>\r\nAVAsset.assetWithURL_(url);\r\n>>> \"MOJavaScriptException: ReferenceError: Can't find variable: AVAsset\"\r\n\r\nframework('AVFoundation');\r\n\r\nAVAsset.assetWithURL_(url);\r\n>>> \"&lt;AVURLAsset: 0x7fe803ce8340&gt;\"\r\n</pre>\r\n\r\nOn OS X, the following frameworks are imported automatically: Foundation, CoreGraphics.\r\n\r\n\r\n## Globals\r\n\r\n### Global Objects\r\n\r\nArbitrary Objective-C objects and methods can be exposed as global objects to the runtime without needing to declare BridgeSupport information. The `Mocha` class is a fully Key-Value Coding compliant container for just this purpose. Calling `-valueForKey:` and `-setValue:forKey:` exposes an object to the runtime, assuming it can be boxed as an appropriate JavaScript type (see above).\r\n\r\n#### Example:\r\n<pre>\r\n// ObjC\r\nMocha *runtime = [Mocha sharedRuntime];\r\nMyClass *object = [[[MyClass alloc] init];\r\n[runtime setValue:object forKey:@\"MyObject\"];\r\n\r\n// JavaScript\r\nvar result = MyObject.someMethod();\r\n</pre>\r\n\r\n### Global Functions\r\n\r\nTo expose arbitrary global functions to the runtime, use the `MOMethod` class. Instances of the class keep reference to a target object and Objective-C selector, which can be invoked dynamically by the runtime whenever the method is called on the JavaScript side of the bridge. Like all other objects, methods can be exposed using the `-valueForKey:` and `-setValue:forKey:` methods of the `Mocha` class.\r\n\r\n#### Example:\r\n<pre>\r\n// ObjC\r\nMocha *runtime = [Mocha sharedRuntime];\r\nMOMethod *method = [MOMethod methodWithTarget:myObject selector:@selector(someMethod)];\r\n[runtime setValue:method forKey:@\"someMethod\"];\r\n\r\n// JavaScript\r\nvar result = someMethod();\r\n</pre>\r\n\r\n\r\n## Pointers\r\n\r\nSome C functions and Cocoa methods expect pointers to types. This introduces an issue to bridged languages that do not have the concept of pointers, like JavaScript. The runtime solves this by exposing a mechanism for creating pointers to values explicitly.\r\n\r\nCreating a pointer will wrap a value in an opaque container, which will be passed properly to functions and methods which expect a pointer type.\r\n\r\nPointer arguments typically come in one of three flavors:\r\n- `in`, where the value is simply passed by reference\r\n- `out`, where the function or method may modify the value of the pointer on output\r\n- `inout`, a combination of **in** and **out**\r\n\r\n### In Arguments\r\n\r\nIn arguments are just normal by-reference value arguments. As such, the runtime handles these transparently. If a function or method expects a pointer to an NSRect structure, you can pass it along like so:\r\n\r\n#### Example\r\n<pre>\r\n// ObjC\r\n@interface MyClass : NSObject\r\n- (CGFloat)getWidthOfRect:(const NSRect *)rect;\r\n@end\r\n\r\n// JavaScript\r\nvar rect = NSMakeRect(0.0, 0.0, 100.0, 100.0:\r\nvar ptr = MOPointer.alloc().initWithValue_(rect);\r\n\r\nmyObject.getWidthOfRect_(ptr);\r\n>>> 100.0;\r\n</pre>\r\n\r\n\r\n### Out Arguments\r\n\r\nOut arguments are commonly used to return more than one value from a function or method. Cocoa uses this paradigm often to return error objects in the case where an operation fails.\r\n\r\nNSScanner also uses this paradigm for its scanning methods. The -scanFloat: method returns a BOOL indicating whether a value was successfully scanned. The argument passed is a pointer to a value that will be modified on the method's return.\r\n\r\n#### Example\r\n<pre>\r\n// JavaScript\r\nvar scanner = NSScanner.alloc().initWithString_(\"3.14159\");\r\nvar ptr = MOPointer.alloc().init();\r\n\r\nscanner.scanFloat_(ptr);\r\n\r\nptr.value();\r\n>>> 3.14159\r\n</pre>\r\n\r\n\r\n### Inout arguments\r\n\r\nInout argument don't require anything special. They are just a combination of the two previous types of arguments.\r\n\r\n\r\n## Object Subscripting\r\n\r\nObjects that support indexed-access (acting as array-types) or keyed-access (acting as dictionary-types) can support the JavaScript subscripting syntax for accessing values.\r\n\r\n### Indexed Subscripting\r\n\r\nImplementing `-objectForIndexedSubscript:` allows an object to use the `object[idx]` syntax for read-only access to values. For read-write access, you should also implement the `-setObject:forIndexedSubscript:` method. Both of these methods are declared within an informal protocol defined in MochaRuntime.h.\r\n\r\n`NSArray` and `NSMutableArray`, and `NSOrderedSet` and `NSMutableOrderedSet` automatically adopt this syntax (through a swizzled category on 10.7 and before, or through automatically supporting the Objective-C indexed subscripting syntax on 10.8+).\r\n\r\n### Keyed Subscripting\r\n\r\nImplementing `-objectForKeyedSubscript:` allows an object to use the `object['key']` syntax for read-only access to values. For read-write access, you should also implement the `-setObject:forKeyedSubscript:` method. Both of these methods are declared within an informal protocol defined in MochaRuntime.h.\r\n\r\n`NSDictionary` and `NSMutableDictionary` automatically adopt this syntax (through a swizzled category on 10.7 and before, or through automatically supporting the Objective-C keyed subscripting syntax on 10.8+).\r\n\r\n\r\n## Introspecting the Objective-C Runtime\r\n\r\nMocha adds several facilities for introspecting the Objective-C runtime. The built-in object `objc` can be used to query various attributes about the Objective-C runtime. Use the `-classes` method to get a list of classes registered with the runtime, or `-protocols` method to get a list of protocols registered with the runtime.\r\n\r\nAn NSObject category is also added by the Mocha runtime to add additional introspection abilities to class objects. Use the `+mocha` method on any class object to get an MOClassDescription object, which is used in describing the class's abilities and layout.\r\n\r\nMOClassDescription gives access to a class's instance variables, class and instance methods, properties and conformed protocols. Use the `+ancestors` method to get a list of a class's superclass chain. Use the `+classMethods`, `+instanceMethods`, `+properties`, and `+protocols` methods to query information about a class's class methods, instance methods, properties, and protocols, respectively. Note that these methods only return methods, properties and protocols defined by the class itself. As a convenience, Mocha also provides the following methods to query for the entire superclass chain: `+classMethodsWithAncestors`, `+instanceMethodsWithAncestors`, `+propertiesWithAncestors`, and `+protocolsWithAncestors`.\r\n\r\nIn addition, MOClassDescription has the ability to add methods to existing classes, or even to define and register completly new classes from within the Mocha runtime.\r\n\r\nFacilities are also provided for introspecting Objective-C protocols through the MOProtocolDescription class in a similar way to class introspection. Similarly, new protocols can be defined and existing protocols can be amended.\r\n\r\n\r\n## Exceptions\r\n\r\nExceptions in Objective-C code can be automatically caught by JavaScript exception handlers. The value of the `err` argument within the `try {} catch (err) {}` block will be a boxed `NSException` instance.\r\n\r\nJavaScript exceptions that are uncaught will be converted to `NSException` objects with a name of `MOJavaScriptException`. They can be caught in an Objective-C `@try {} @catch (NSException *e) {}` block just like any other exception.\r\n\r\nMocha exceptions that do not originate from within the JavaScript environment carry the name `MORuntimeException`, and generally indicate a more serious failure caused by an issue within the runtime.\r\n\r\n\r\n## mocha: The Mocha Interpreter\r\n\r\n`mocha` is the command-line interpreter for Mocha. It has two modes: script and interactive. Its scripting mode is similar to `python` and `ruby`. Its interactive mode is similar to `python`, `irb`, and `jsc`.\r\n\r\n### Interactive\r\n\r\nInteractive mode adds the following set of built-in functions:\r\n- `exit()` – Exits the interpreter\r\n- `gc()` – Instructs the JavaScript garbage collector to perform a collection\r\n- `checkSyntax(string)` – Validates the syntax of `string`, returning a `Boolean`\r\n\r\n### Scripting\r\n\r\nYou can use `mocha` the same way you use other scripting envorinments. Add a shebang declaration to the top of a script to enable its use on the command line, like so:\r\n\r\n### Example\r\n<pre>\r\n#!/usr/local/bin/mocha\r\n\r\nvar d = {};\r\nd['foo'] = 'bar';\r\nd['baz'] = 1.0;\r\nd['bin'] = ['foo', 'bar', 'baz'];\r\n\r\nprint(d);\r\n</pre>\r\n\r\n\r\n## Using Mocha with OS X\r\n\r\nTo use Mocha in your OS X project, follow these steps:\r\n\r\n1. Add the **Mocha project** to your project (by dragging the *.xcodeproj file to your Frameworks group in Xcode).\r\n2. Open your target's **Build Phases**, and under the **Link Binary With Libraries** build phase, click Add and choose **Mocha.framework** from the workspace.\r\n3. Build!\r\n\r\n\r\n## Using Mocha with iOS\r\n\r\nMocha works with iOS, too! libMocha is a static library built for iOS targets. To use libMocha in your project, follow these steps:\r\n\r\n1. Add the **Mocha project** to your project (by dragging the *.xcodeproj file to your Frameworks group in Xcode).\r\n2. Open your target's **Build Phases**, and under the **Link Binary With Libraries** build phase, click Add and choose **libMocha** from the workspace.\r\n3. Next, add the following system libraries the same way: **libstdc++.dylib**, **libicucore.dylib**.\r\n4. Open your target's **Build Settings** and add **-ObjC** to your **Other Linker Flags**.\r\n5. Under your **Header Search Paths** add **${BUILT_PRODUCTS_DIR}/usr/local/include** and **\"${SRCROOT}/(path to Mocha's source folder)/libMocha (iOS)/JavaScriptCore\"**\r\n6. Build!\r\n\r\n\r\n## To Do's\r\n\r\nThe following items are currently on the docket for future development:\r\n\r\n- ~~iOS Support~~ (Added 5/20/12)\r\n- ~~Runtime support for creating and modifying Objective-C classes~~ (Added 6/13/12)\r\n- Objective-J/JSTalk-style syntax for defining Objective-C classes and categories\r\n\r\n\r\n## Code Usage\r\n\r\nMocha utilizes code and ideas from the following projects:\r\n\r\n- PyObjC (http://pyobjc.sourceforge.net/, MIT license)\r\n- JSCocoa (http://inexdo.com/JSCocoa, MIT license)\r\n- JavaScriptCore (http://www.webkit.org/projects/javascript/index.html, WebKit license).\r\n- libffi-iphone (https://github.com/parmanoir/libffi-iphone, MIT license)\r\n- JavaScriptCore-iOS (http://www.phoboslab.org/log/2011/06/javascriptcore-project-files-for-ios, WebKit license).\r\n\r\nFiles are marked appropriately when code it utilized in complete or near-complete duplicate from these awesome projects.\r\n\r\n\r\n## License\r\n\r\nCopyright 2012 Logan Collins\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}